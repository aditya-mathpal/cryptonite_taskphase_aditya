# babygame01

First test the game out by connecting to the server. By experimentation it can be seen that wasd keys move the 'player' and hitting p directly lets the player win.  
Decompile the given binary with Ghidra to check for a way to find the flag.  
This piece of code in main() stands out:
```
do {
    do {
        iVar1 = getchar();
        move_player(&local_aac,(int)(char)iVar1,local_aa0);
        print_map(local_aa0,&local_aac);
    } while (local_aac != 29);
} while (local_aa8 != 89);
puts("You win!");
if (local_aa4 != '\0') {
    puts("flage");
    win();
    fflush(_stdout);
}
```
It seems like to get the flag, the variable `local_aa4` has to not be null.  
To figure out what these variables represent, we must analyse the functions.  
In `print_map(int param_1,undefined4 param_2)` there exist three functions:  
```
find_player_pos(param_1);
find_end_tile_pos(param_1);
print_flag_status(param_2);
```
Analysing these reveals that they all do exactly as their names suggest. `print_flag_status()` is interesting becuase it prints the boolean that lets the player know whether they have the flag.  
We can go back to find out that the parameter `print_flag_status()` is taking is the reference to `local_aac` and it ends up displaying the content stored 8 bytes ahead of it.  
The above code snippet also makes it evident that `local_aac` is the y coordinate of the map and `local_aa8` is x.

The `init_player()` function clarifies a lot:
```
void init_player(undefined4 *param_1)

{
  *param_1 = 4;
  param_1[1] = 4;
  *(undefined *)(param_1 + 2) = 0;
  return;
}
```
It takes the reference to `local_aac` and for every 4 bytes it assigns 4, 4, and 0, respectively. This lines up with the position of the player and flag status that is printed above the map in the game.  
So this implies that `local_aac`, `local_aa8`, and `local_aa4` must be stored in contiguous locations, in that order. It can also be understood that `local_aa0` also lies right after, which seems to be where the map is stored.  
Overflowing `local_aa8` is the first instinct here, but unfortunately it doesn't seem to be possible because there's no clear way to move the 'end tile'. But `local_aa0` could be underflown. Since it's a reference to the map, if the player somehow moves 4 bytes behind it, they could overflow the flag status variable, i.e. `local_aa4`.  

In `move_player()` we can see that a is the keystroke that reduces the variable that is stored after `local_aac`. It's only decremented by 1, so hitting it 4 times should affect `local_aa4`.

Test this by first going to (0,0) by typing `wwwwaaaa` in the terminal. Now hit a till the flag status changes, as expected it was 4 times. It now reads `Player has flag: 64`. As we figured out in the beginning and can be seen in the `move_player()` function, hitting p allows us to jump to the end of the game. Doing it with the flag status not null makes `win()` run and subsequently print the flag to the terminal.

# babygame02